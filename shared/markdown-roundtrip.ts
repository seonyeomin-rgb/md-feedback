import type { Memo, MemoV2, ReviewHighlight, ReviewMemo, Checkpoint } from './types'
import { HEX_TO_COLOR_NAME } from './types'
import { splitDocument } from './document-writer'

const HEX_TO_COLOR = HEX_TO_COLOR_NAME

/**
 * Convert USER_MEMO comments to <div data-memo-block> HTML that TipTap can parse.
 * Also strips non-visual metadata (GATE, PLAN_CURSOR, CHECKPOINT).
 * This preserves memo data through the save/reload cycle.
 */
export function convertMemosToHtml(markdown: string): string {
  const lines = markdown.split('\n')
  const result: string[] = []
  let i = 0

  while (i < lines.length) {
    const line = lines[i]
    const trimmed = line.trim()

    // v0.3 single-line memo (handles extended attrs like owner, source)
    // <!-- USER_MEMO id="abc" color="red" ... : feedback text -->
    const v3Match = trimmed.match(/^<!-- USER_MEMO\s+id="([^"]+)"\s+(.*?)\s*:\s*(.*?)\s*-->$/)
    if (v3Match) {
      const id = v3Match[1]
      const attrStr = v3Match[2]
      const text = v3Match[3].replace(/--\u200B>/g, '-->')

      const colorMatch = attrStr.match(/color="([^"]+)"/)
      const statusMatch = attrStr.match(/status="([^"]+)"/)
      const color = colorMatch ? colorMatch[1] : 'red'
      const status = statusMatch ? statusMatch[1] : 'open'

      const encText = escAttr(text)
      result.push(`<div data-memo-block data-memo-id="${id}" data-memo-text="${encText}" data-memo-color="${color}" data-memo-status="${status}">memo: ${escHtml(text)}</div>`)
      i++
      continue
    }

    // v0.4 multi-line memo: <!-- USER_MEMO\n  key="val"\n  ...\n-->
    if (/^<!-- USER_MEMO\s*$/.test(trimmed)) {
      const attrLines: string[] = []
      i++
      while (i < lines.length && !/^-->$/.test(lines[i].trim())) {
        attrLines.push(lines[i])
        i++
      }
      i++ // skip -->

      const attrs: Record<string, string> = {}
      for (const al of attrLines) {
        const m = al.trim().match(/^(\w+)="([^"]*)"$/)
        if (m) attrs[m[1]] = m[2]
      }

      const id = attrs.id || ''
      const color = attrs.color || 'red'
      const status = attrs.status || 'open'
      const text = attrs.text || ''
      const anchorText = attrs.anchorText || ''

      const encText = escAttr(text)
      const encAnchor = escAttr(anchorText)
      result.push(`<div data-memo-block data-memo-id="${id}" data-memo-text="${encText}" data-memo-color="${color}" data-memo-status="${status}" data-memo-anchor="${encAnchor}">memo: ${escHtml(text)}</div>`)
      continue
    }

    // Skip <!-- /USER_MEMO --> closing tags
    if (/^<!-- \/USER_MEMO\s*-->$/.test(trimmed)) {
      i++
      continue
    }

    // Skip GATE blocks
    if (/^<!-- GATE\s*$/.test(trimmed)) {
      i++
      while (i < lines.length && !/^-->$/.test(lines[i].trim())) i++
      i++
      continue
    }

    // Skip PLAN_CURSOR blocks
    if (/^<!-- PLAN_CURSOR\s*$/.test(trimmed)) {
      i++
      while (i < lines.length && !/^-->$/.test(lines[i].trim())) i++
      i++
      continue
    }

    // Skip CHECKPOINT lines
    if (/^<!-- CHECKPOINT\s/.test(trimmed)) {
      i++
      continue
    }

    // Skip banner comments
    if (/^<!--$/.test(trimmed) && i + 1 < lines.length && /MD Feedback/.test(lines[i + 1])) {
      while (i < lines.length && !lines[i].includes('-->')) i++
      i++
      continue
    }

    // Skip feedback notes wrappers
    if (/^<!-- \/?(USER_FEEDBACK_NOTES|@\/?feedback-notes)\b.*-->$/.test(trimmed)) {
      i++
      continue
    }

    // Legacy memo blocks: <!-- @memo ... --> ... <!-- @/memo -->
    const legacyMatch = trimmed.match(/^<!-- @memo\s+id="([^"]+)"(?:\s+color="([^"]+)")?\s*-->$/)
    if (legacyMatch) {
      const memoContentLines: string[] = []
      i++
      while (i < lines.length && !/^<!-- @\/memo -->$/.test(lines[i].trim())) {
        memoContentLines.push(lines[i])
        i++
      }
      i++ // skip <!-- @/memo -->
      const text = memoContentLines.map(l => l.replace(/^<!--\s*/, '').replace(/\s*-->$/, '')).join('\n').trim()
      const id = legacyMatch[1]
      const color = legacyMatch[2] || 'red'
      const encText = escAttr(text)
      result.push(`<div data-memo-block data-memo-id="${id}" data-memo-text="${encText}" data-memo-color="${color}" data-memo-status="open">memo: ${escHtml(text)}</div>`)
      continue
    }

    result.push(line)
    i++
  }

  // Trim trailing empty lines
  while (result.length > 0 && result[result.length - 1].trim() === '') {
    result.pop()
  }

  return result.join('\n')
}

function escAttr(s: string): string {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
}

function escHtml(s: string): string {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
}

export function extractMemos(annotatedMarkdown: string): { markdown: string; memos: Memo[] } {
  const memos: Memo[] = []
  const lines = annotatedMarkdown.split('\n')
  const cleanLines: string[] = []
  let inLegacyMemo = false
  let currentMemo: Partial<Memo> | null = null
  let memoContentLines: string[] = []
  let anchorLineContent: string | null = null

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]

    if (line.trim() === '<!--' && i + 1 < lines.length && lines[i + 1].includes('MD Feedback')) {
      while (i < lines.length && !lines[i].includes('-->')) i++
      continue
    }

    const newMatch = line.match(/<!-- USER_MEMO\s+id="([^"]+)"(?:\s+color="([^"]+)")?(?:\s+status="([^"]+)")?\s*:\s*(.*?)\s*-->/)
    if (newMatch) {
      let anchor: string | null = null
      for (let j = cleanLines.length - 1; j >= 0; j--) {
        if (cleanLines[j].trim()) { anchor = cleanLines[j].trim(); break }
      }
      memos.push({
        id: newMatch[1],
        text: newMatch[4].replace(/--\u200B>/g, '-->'),
        color: (newMatch[2] as Memo['color']) || 'red',
        anchorPos: null,
        anchorText: anchor,
        createdAt: new Date().toISOString().split('T')[0],
      })
      continue
    }

    const legacyStart = line.match(/<!-- @memo\s+id="([^"]+)"(?:\s+color="([^"]+)")?(?:\s+date="([^"]+)")?\s*-->/)
    if (legacyStart) {
      inLegacyMemo = true
      currentMemo = {
        id: legacyStart[1],
        color: (legacyStart[2] as Memo['color']) || 'red',
        createdAt: legacyStart[3] || new Date().toISOString().split('T')[0],
      }
      memoContentLines = []
      for (let j = cleanLines.length - 1; j >= 0; j--) {
        if (cleanLines[j].trim()) { anchorLineContent = cleanLines[j].trim(); break }
      }
      continue
    }

    if (line.match(/<!-- @\/memo -->/)) {
      if (currentMemo) {
        const text = memoContentLines.map(l => l.replace(/^<!--\s*/, '').replace(/\s*-->$/, '')).join('\n').trim()
        memos.push({
          id: currentMemo.id!,
          text,
          color: currentMemo.color as Memo['color'],
          anchorPos: null,
          anchorText: anchorLineContent,
          createdAt: currentMemo.createdAt!,
        })
      }
      inLegacyMemo = false
      currentMemo = null
      anchorLineContent = null
      continue
    }

    if (inLegacyMemo) { memoContentLines.push(line); continue }
    if (line.match(/<!-- \/?USER_FEEDBACK_NOTES\b.*-->/) || line.match(/<!-- @\/?feedback-notes -->/)) continue

    cleanLines.push(line)
  }

  while (cleanLines.length > 0 && cleanLines[cleanLines.length - 1].trim() === '') cleanLines.pop()
  return { markdown: cleanLines.join('\n'), memos }
}

export function normalizeHighlights(markdown: string): string {
  // Split by fenced code blocks to avoid matching ==text== inside them
  const parts = markdown.split(/(^```[\s\S]*?^```|^~~~[\s\S]*?^~~~)/gm)
  return parts.map((part, i) => {
    // Odd indices are code blocks — preserve as-is
    if (i % 2 === 1) return part
    // Even indices are normal content — normalize ==text== to <mark>
    return part.replace(/(?<!`)==(?!.*==.*`)(.+?)==(?!`)/g, '<mark>$1</mark>')
  }).join('')
}

/**
 * Extract memos as v0.4.0 MemoV2 with status/owner/source.
 * Handles both v0.3 single-line and v0.4 multi-line formats.
 * v0.3 memos auto-fill: status=open, owner=human, source=generic.
 */
export function extractMemosV2(annotatedMarkdown: string): { markdown: string; memos: MemoV2[] } {
  const parts = splitDocument(annotatedMarkdown)
  return { markdown: parts.body, memos: parts.memos }
}

/* ── Share to AI: compact review protocol for agent consumption ── */

interface FeedbackItem {
  type: 'fix' | 'question' | 'important'
  text: string
  section: string
  context: string
  feedback: string
}

function collectItems(
  highlights: ReviewHighlight[],
  docMemos: ReviewMemo[],
  floatingMemos: Memo[],
): FeedbackItem[] {
  const items: FeedbackItem[] = []
  const matchedHighlights = new Set<number>()

  for (const memo of docMemos) {
    const cn = memo.color.startsWith('#') ? (HEX_TO_COLOR[memo.color] || 'red') : memo.color
    const type = cn === 'red' ? 'fix' : cn === 'blue' ? 'question' : 'important'

    const hlColor = cn === 'red' ? '#fca5a5' : cn === 'blue' ? '#93c5fd' : '#fef08a'
    const hlIdx = highlights.findIndex((hl, idx) =>
      !matchedHighlights.has(idx) && hl.color === hlColor && memo.section === hl.section,
    )

    if (hlIdx >= 0) {
      matchedHighlights.add(hlIdx)
      items.push({
        type,
        text: highlights[hlIdx].text,
        section: memo.section || highlights[hlIdx].section || '',
        context: highlights[hlIdx].context || '',
        feedback: memo.text,
      })
    } else {
      items.push({
        type,
        text: memo.context || '',
        section: memo.section || '',
        context: '',
        feedback: memo.text,
      })
    }
  }

  for (let i = 0; i < highlights.length; i++) {
    if (matchedHighlights.has(i)) continue
    const hl = highlights[i]
    const cn = HEX_TO_COLOR[hl.color] || 'yellow'
    const type = cn === 'red' ? 'fix' : cn === 'blue' ? 'question' : 'important'
    items.push({
      type,
      text: hl.text,
      section: hl.section || '',
      context: hl.context || '',
      feedback: '',
    })
  }

  for (const memo of floatingMemos.filter(m => m.text.trim())) {
    const type = memo.color === 'red' ? 'fix' : memo.color === 'blue' ? 'question' : 'important'
    items.push({
      type,
      text: '',
      section: '',
      context: '',
      feedback: memo.text,
    })
  }

  return items
}

export function generateReviewSummary(
  title: string,
  highlights: ReviewHighlight[],
  docMemos: ReviewMemo[],
  floatingMemos: Memo[],
  filePath: string = '',
): string {
  const items = collectItems(highlights, docMemos, floatingMemos)
  const fp = filePath || '(file path not set)'
  const docTitle = title || 'Untitled'

  if (items.length === 0) {
    return `# REVIEW: ${docTitle}\n\n**File:** \`${fp}\`\n\nNo feedback.`
  }

  const fixes = items.filter(i => i.type === 'fix')
  const questions = items.filter(i => i.type === 'question')
  const importants = items.filter(i => i.type === 'important')

  const counts: string[] = []
  if (fixes.length) counts.push(`${fixes.length} fix`)
  if (questions.length) counts.push(`${questions.length} question`)
  if (importants.length) counts.push(`${importants.length} note`)

  const L: string[] = []

  L.push(`# REVIEW FEEDBACK — \`${fp}\``)
  L.push('')
  L.push(`**Document:** ${docTitle}`)
  L.push(`**Items:** ${counts.join(', ')} (${items.length} total)`)
  L.push('')

  if (fixes.length > 0) {
    L.push('## FIX (edit the source file)')
    L.push('')
    for (let i = 0; i < fixes.length; i++) {
      const f = fixes[i]
      const prefix = `${i + 1}.`
      const section = f.section ? `**${f.section}**` : '**General**'

      if (f.text) {
        L.push(`${prefix} ${section} — "${truncate(f.text, 80)}"`)
      } else {
        L.push(`${prefix} ${section}`)
      }

      if (f.feedback) {
        L.push(`   ${f.feedback}`)
      }
      L.push('')
    }
  }

  if (questions.length > 0) {
    L.push('## QUESTION (investigate and clarify)')
    L.push('')
    for (let i = 0; i < questions.length; i++) {
      const q = questions[i]
      const prefix = `${i + 1}.`
      const section = q.section ? `**${q.section}**` : '**General**'

      if (q.text) {
        L.push(`${prefix} ${section} — "${truncate(q.text, 80)}"`)
      } else {
        L.push(`${prefix} ${section}`)
      }

      if (q.feedback) {
        L.push(`   ${q.feedback}`)
      }
      L.push('')
    }
  }

  if (importants.length > 0) {
    L.push('## IMPORTANT (context for your work)')
    L.push('')
    for (const imp of importants) {
      const section = imp.section ? `**${imp.section}**` : '**General**'
      if (imp.text) {
        L.push(`- ${section} — "${truncate(imp.text, 80)}"`)
      }
      if (imp.feedback) {
        L.push(`- ${section} — ${imp.feedback}`)
      }
    }
    L.push('')
  }

  return L.join('\n').trimEnd()
}

function truncate(s: string, len: number): string {
  return s.length > len ? s.slice(0, len) + '...' : s
}

// ─── Checkpoint roundtrip ───

const CHECKPOINT_RE = /<!-- CHECKPOINT id="([^"]+)" time="([^"]+)" note="([^"]*)" fixes=(\d+) questions=(\d+) highlights=(\d+) sections="([^"]*)" -->/g

export function extractCheckpoints(markdown: string): Checkpoint[] {
  const checkpoints: Checkpoint[] = []
  let match: RegExpExecArray | null
  while ((match = CHECKPOINT_RE.exec(markdown)) !== null) {
    checkpoints.push({
      id: match[1],
      timestamp: match[2],
      note: match[3],
      fixes: parseInt(match[4], 10),
      questions: parseInt(match[5], 10),
      highlights: parseInt(match[6], 10),
      sectionsReviewed: match[7] ? match[7].split(',') : [],
    })
  }
  CHECKPOINT_RE.lastIndex = 0
  return checkpoints
}

export function serializeCheckpoint(cp: Checkpoint): string {
  const note = cp.note.replace(/"/g, '&quot;')
  const sections = cp.sectionsReviewed.join(',')
  return `<!-- CHECKPOINT id="${cp.id}" time="${cp.timestamp}" note="${note}" fixes=${cp.fixes} questions=${cp.questions} highlights=${cp.highlights} sections="${sections}" -->`
}
